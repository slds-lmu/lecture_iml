\aufgabe{Counterfactuals - WhatIf}{

Counterfactual explanations are a valuable tool to explain predictions of 
machine learning models. They tell the user how features need to be changed 
in order to predict a desired outcome. 
One of the simplest approaches to generate counterfactuals is to determine for 
a given observation $x$ (\texttt{x\_interest}) the closest data point which has a prediction equal to 
the desired outcome.\footnote{Wexler et al. (2019): "The What-If Tool: Interactive Probing of Machine Learning Models"} 
In the following exercise, you should implement this so called WhatIf approach for a binary classifier.
The associated files for this exercise are \textit{whatif.py} or \textit{whatif.R}.

\begin{enumerate}[a)]
  \item Implement the following steps in \texttt{generate\_whatif()}: 
  \begin{enumerate}
    \item Subset the \texttt{data} to the observations having a 
    prediction different to the one of \texttt{x\_interest} (this is equal to our desired prediction). 
    \item Calculate the pairwise Gower's distances between \texttt{x\_interest} and the 
    remaining data points in \texttt{data}.\\ 
    \textit{Hint:} the \texttt{StatMatch} package in R and \texttt{gower} in Python offer implementations of Gower's distance.
    \item Return the nearest data point as a counterfactual for \texttt{x\_interest}.
  \end{enumerate}
  Try out your function with the provided example code. 
  
  \item Which attributes from the lecture (\textit{validity}, \textit{sparsity}, ...)
  does this approach fulfill. Based on this, derive the advantages and disadvantages of the approach.
  
  \item In order to evaluate the sparseness of the counterfactual produced by WhatIf, we could use the following approach: 
  For each feature of the counterfactual instance assess whether setting its 
  value to the one of \texttt{x\_interest} still leads to a different prediction 
  than \texttt{x\_interest}.
  Complete the function \texttt{evaluate\_cfexp()} using the following steps: 
  
  \begin{enumerate}
    \item Create an empty vector \texttt{feature\_nams}.
    \item For each feature do the following: 
    \begin{enumerate}
    \item Create a copy of the counterfactual.
    \item Replace the feature value of this copy with the value of \texttt{x\_interest}. 
    \item Evaluate if the prediction for this copy still differs to the one of \texttt{x\_interest}. 
    \item If it still differs, add the name of this feature to \texttt{feature\_nams}.
    \end{enumerate}
    \item End for - return \texttt{feature\_nams}.
  \end{enumerate}
  
  Try out your function given the code example and think about possible extensions of this approach.
  
\end{enumerate}
}
